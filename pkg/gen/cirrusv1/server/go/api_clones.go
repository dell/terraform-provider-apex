/*
 * APEX Navigator for Multicloud Storage REST APIs
 *
 * The public API definitions for APEX Navigator for Multicloud Storage
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// ClonesAPIController binds http requests to an api service and writes the service results to the http response
type ClonesAPIController struct {
	service      ClonesAPIServicer
	errorHandler ErrorHandler
}

// ClonesAPIOption for how the controller is set up.
type ClonesAPIOption func(*ClonesAPIController)

// WithClonesAPIErrorHandler inject ErrorHandler into controller
func WithClonesAPIErrorHandler(h ErrorHandler) ClonesAPIOption {
	return func(c *ClonesAPIController) {
		c.errorHandler = h
	}
}

// NewClonesAPIController creates a default api controller
func NewClonesAPIController(s ClonesAPIServicer, opts ...ClonesAPIOption) Router {
	controller := &ClonesAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the ClonesAPIController
func (c *ClonesAPIController) Routes() Routes {
	return Routes{
		"ClonesCollection": Route{
			strings.ToUpper("Get"),
			"/rest/services/storage/v1/clones",
			c.ClonesCollection,
		},
		"ClonesCreate": Route{
			strings.ToUpper("Post"),
			"/rest/services/storage/v1/clones",
			c.ClonesCreate,
		},
		"ClonesDelete": Route{
			strings.ToUpper("Delete"),
			"/rest/services/storage/v1/clones/{clone_id}",
			c.ClonesDelete,
		},
		"ClonesInstance": Route{
			strings.ToUpper("Get"),
			"/rest/services/storage/v1/clones/{clone_id}",
			c.ClonesInstance,
		},
		"ClonesMap": Route{
			strings.ToUpper("Post"),
			"/rest/services/storage/v1/clones/{clone_id}/map",
			c.ClonesMap,
		},
		"ClonesModify": Route{
			strings.ToUpper("Patch"),
			"/rest/services/storage/v1/clones/{clone_id}",
			c.ClonesModify,
		},
		"ClonesRefresh": Route{
			strings.ToUpper("Post"),
			"/rest/services/storage/v1/clones/{clone_id}/refresh",
			c.ClonesRefresh,
		},
		"ClonesUnmap": Route{
			strings.ToUpper("Post"),
			"/rest/services/storage/v1/clones/{clone_id}/unmap",
			c.ClonesUnmap,
		},
	}
}

// ClonesCollection - Get all clones
func (c *ClonesAPIController) ClonesCollection(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	var filterParam string
	if query.Has("filter") {
		param := query.Get("filter")

		filterParam = param
	} else {
	}
	var select_Param string
	if query.Has("select") {
		param := query.Get("select")

		select_Param = param
	} else {
	}
	var orderParam string
	if query.Has("order") {
		param := query.Get("order")

		orderParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
			WithMaximum[int32](1000),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](0),
			WithMaximum[int32](1000),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	result, err := c.service.ClonesCollection(r.Context(), filterParam, select_Param, orderParam, limitParam, offsetParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesCreate - Create Clone
func (c *ClonesAPIController) ClonesCreate(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	cloneCreateInputParam := CloneCreateInput{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&cloneCreateInputParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertCloneCreateInputRequired(cloneCreateInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertCloneCreateInputConstraints(cloneCreateInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ClonesCreate(r.Context(), asyncParam, cloneCreateInputParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesDelete - Delete a clone
func (c *ClonesAPIController) ClonesDelete(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	cloneIdParam := params["clone_id"]
	if cloneIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"clone_id"}, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	deleteCloneInputParam := DeleteCloneInput{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&deleteCloneInputParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertDeleteCloneInputRequired(deleteCloneInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertDeleteCloneInputConstraints(deleteCloneInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ClonesDelete(r.Context(), cloneIdParam, asyncParam, deleteCloneInputParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesInstance - Get a clone
func (c *ClonesAPIController) ClonesInstance(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	cloneIdParam := params["clone_id"]
	if cloneIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"clone_id"}, nil)
		return
	}
	var select_Param string
	if query.Has("select") {
		param := query.Get("select")

		select_Param = param
	} else {
	}
	result, err := c.service.ClonesInstance(r.Context(), cloneIdParam, select_Param)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesMap - Map hosts to clone
func (c *ClonesAPIController) ClonesMap(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	cloneIdParam := params["clone_id"]
	if cloneIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"clone_id"}, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	mapInputParam := MapInput{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&mapInputParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertMapInputRequired(mapInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertMapInputConstraints(mapInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ClonesMap(r.Context(), cloneIdParam, asyncParam, mapInputParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesModify - Update clone
func (c *ClonesAPIController) ClonesModify(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	cloneIdParam := params["clone_id"]
	if cloneIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"clone_id"}, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	updateCloneInputParam := UpdateCloneInput{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&updateCloneInputParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertUpdateCloneInputRequired(updateCloneInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertUpdateCloneInputConstraints(updateCloneInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ClonesModify(r.Context(), cloneIdParam, asyncParam, updateCloneInputParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesRefresh - Refresh Clone
func (c *ClonesAPIController) ClonesRefresh(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	cloneIdParam := params["clone_id"]
	if cloneIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"clone_id"}, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	result, err := c.service.ClonesRefresh(r.Context(), cloneIdParam, asyncParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// ClonesUnmap - Unmap hosts from clone
func (c *ClonesAPIController) ClonesUnmap(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	cloneIdParam := params["clone_id"]
	if cloneIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"clone_id"}, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	unmapInputParam := UnmapInput{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&unmapInputParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertUnmapInputRequired(unmapInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertUnmapInputConstraints(unmapInputParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ClonesUnmap(r.Context(), cloneIdParam, asyncParam, unmapInputParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
